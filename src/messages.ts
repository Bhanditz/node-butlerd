
// These bindings were generated by busegen
// - At 2018-02-25 19:57:52.0002686 +0100 CET m=+0.209638601
// - From https://github.com/itchio/butler/commit/36430526daf07a93531c56abbd101e0afe085e36

// See <https://docs.itch.ovh/buse/master> for a human-friendly documentation

import { createRequest, createNotification, Client, IRequest, INotification } from "./client";

/**
 * Retrieves the version of the butler instance the client
 * is connected to.
 * 
 * This endpoint is meant to gather information when reporting
 * issues, rather than feature sniffing. Conforming clients should
 * automatically download new versions of butler, see the **Updating** section.
 */
export interface VersionGetParams {
  // no fields
}

/**
 * Result for Version.Get
 */
export interface VersionGetResult {
  /** Something short, like `v8.0.0` */
  version: string;
  /** Something long, like `v8.0.0, built on Aug 27 2017 @ 01:13:55, ref d833cc0aeea81c236c81dffb27bc18b2b8d8b290` */
  versionString: string;
}

export const VersionGet = 
	createRequest<VersionGetParams, VersionGetResult>("Version.Get");

/**
 * Result for Game.FindUploads
 */
export interface GameFindUploadsResult {
  /** A list of uploads that were found to be compatible. */
  uploads: Upload[];
}

export const GameFindUploads = 
	createRequest<GameFindUploadsParams, GameFindUploadsResult>("Game.FindUploads");

/**
 * Result for Operation.Start
 */
export interface OperationStartResult {
  // no fields
}

export const OperationStart = 
	createRequest<OperationStartParams, OperationStartResult>("Operation.Start");

/**
 * Result for Operation.Cancel
 */
export interface OperationCancelResult {
  // no fields
}

export const OperationCancel = 
	createRequest<OperationCancelParams, OperationCancelResult>("Operation.Cancel");

/**
 * GameCredentials contains all the credentials required to make API requests
 * including the download key if any.
 */
export interface GameCredentials {
  /** Defaults to `https://itch.io` */
  server?: string;
  /** A valid itch.io API key */
  apiKey: string;
  /** A download key identifier, or 0 if no download key is available */
  downloadKey?: number;
}

/**
 * Result for PickUpload
 */
export interface PickUploadResult {
  /**
   * The index (in the original array) of the upload that was picked,
   * or a negative value to cancel.
   */
  index: number;
}

export const PickUpload = 
	createRequest<PickUploadParams, PickUploadResult>("PickUpload");

/**
 * Result for GetReceipt
 */
export interface GetReceiptResult {
  /** undocumented */
  receipt: Receipt;
}

export const GetReceipt = 
	createRequest<GetReceiptParams, GetReceiptResult>("GetReceipt");

/**
 * Result for CheckUpdate
 */
export interface CheckUpdateResult {
  /** Any updates found (might be empty) */
  updates: GameUpdate[];
  /** Warnings messages logged while looking for updates */
  warnings: string[];
}

export const CheckUpdate = 
	createRequest<CheckUpdateParams, CheckUpdateResult>("CheckUpdate");

/**
 * Result for Launch
 */
export interface LaunchResult {
  // no fields
}

export const Launch = 
	createRequest<LaunchParams, LaunchResult>("Launch");

/**
 * Result for PickManifestAction
 */
export interface PickManifestActionResult {
  /** Name of the action picked by user, or empty is we're aborting. */
  name: string;
}

export const PickManifestAction = 
	createRequest<PickManifestActionParams, PickManifestActionResult>("PickManifestAction");

/**
 * Result for ShellLaunch
 */
export interface ShellLaunchResult {
  // no fields
}

export const ShellLaunch = 
	createRequest<ShellLaunchParams, ShellLaunchResult>("ShellLaunch");

/**
 * Result for HTMLLaunch
 */
export interface HTMLLaunchResult {
  // no fields
}

export const HTMLLaunch = 
	createRequest<HTMLLaunchParams, HTMLLaunchResult>("HTMLLaunch");

/**
 * Result for URLLaunch
 */
export interface URLLaunchResult {
  // no fields
}

export const URLLaunch = 
	createRequest<URLLaunchParams, URLLaunchResult>("URLLaunch");

/**
 * Result for SaveVerdict
 */
export interface SaveVerdictResult {
  // no fields
}

export const SaveVerdict = 
	createRequest<SaveVerdictParams, SaveVerdictResult>("SaveVerdict");

/**
 * Result for AllowSandboxSetup
 */
export interface AllowSandboxSetupResult {
  /** Set to true if user allowed the sandbox setup, false otherwise */
  allow: boolean;
}

export const AllowSandboxSetup = 
	createRequest<AllowSandboxSetupParams, AllowSandboxSetupResult>("AllowSandboxSetup");

/**
 * Result for PrereqsFailed
 */
export interface PrereqsFailedResult {
  /** Set to true if the user wants to proceed with the launch in spite of the prerequisites failure */
  continue: boolean;
}

export const PrereqsFailed = 
	createRequest<PrereqsFailedParams, PrereqsFailedResult>("PrereqsFailed");

/**
 * Sent any time butler needs to send a log message. The client should
 * relay them in their own stdout / stderr, and collect them so they
 * can be part of an issue report if something goes wrong.
 */
export interface LogNotification {
  /** Level of the message (`info`, `warn`, etc.) */
  level: LogLevel;
  /**
   * Contents of the message.
   * 
   * Note: logs may contain non-ASCII characters, or even emojis.
   */
  message: string;
}

export const Log = 
	createNotification<LogNotification>("Log");

/**
 * undocumented
 */
export enum LogLevel {
  // Hidden from logs by default, noisy
  Debug = "debug",
  // Just thinking out loud
  Info = "info",
  // We're continuing, but we're not thrilled about it
  Warning = "warning",
  // We're eventually going to fail loudly
  Error = "error",
}

/**
 * Result for Test.Double
 */
export interface TestDoubleResult {
  /** The number, doubled */
  number: number;
}

export const TestDouble = 
	createRequest<TestDoubleParams, TestDoubleResult>("Test.Double");

/**
 * undocumented
 */
export enum ItchPlatform {
  OSX = "osx",
  Windows = "windows",
  Linux = "linux",
  Unknown = "unknown",
}

/**
 * Buse JSON-RPC 2.0 error codes
 */
export enum Code {
  // An operation was cancelled gracefully
  OperationCancelled = 499,
  // An operation was aborted by the user
  OperationAborted = 410,
}

/**
 * A Manifest describes prerequisites (dependencies) and actions that
 * can be taken while launching a game.
 */
export interface Manifest {
  /** Actions are a list of options to give the user when launching a game. */
  actions: Action[];
  /**
   * Prereqs describe libraries or frameworks that must be installed
   * prior to launching a game
   */
  prereqs: Prereq[];
}

/**
 * An Action is a choice for the user to pick when launching a game.
 * 
 * see https://itch.io/docs/itch/integrating/manifest.html
 */
export interface Action {
  /** human-readable or standard name */
  name: string;
  /** file path (relative to manifest or absolute), URL, etc. */
  path: string;
  /** icon name (see static/fonts/icomoon/demo.html, don't include `icon-` prefix) */
  icon: string;
  /** command-line arguments */
  args: string[];
  /** sandbox opt-in */
  sandbox: boolean;
  /** requested API scope */
  scope: string;
  /** don't redirect stdout/stderr, open in new console window */
  console: boolean;
  /** platform to restrict this action too */
  platform: ItchPlatform;
  /** localized action name */
  locales: Map<string, ActionLocale>;
}

/**
 * undocumented
 */
export interface Prereq {
  /** A prerequisite to be installed, see <https://itch.io/docs/itch/integrating/prereqs/> for the full list. */
  name: string;
}

/**
 * undocumented
 */
export interface ActionLocale {
  /** A localized action name */
  name: string;
}

/**
 * User represents an itch.io account, with basic profile info
 */
export interface User {
  /** Site-wide unique identifier generated by itch.io */
  id: number;
  /** The user's username (used for login) */
  username: string;
  /** The user's display name: human-friendly, may contain spaces, unicode etc. */
  displayName: string;
  /** Has the user opted into creating games? */
  developer: boolean;
  /** Is the user part of itch.io's press program? */
  pressUser: boolean;
  /** The address of the user's page on itch.io */
  url: string;
  /** User's avatar, may be a GIF */
  coverUrl: string;
  /** Static version of user's avatar, only set if the main cover URL is a GIF */
  stillCoverUrl: string;
}

/**
 * Game represents a page on itch.io, it could be a game,
 * a tool, a comic, etc.
 */
export interface Game {
  /** Site-wide unique identifier generated by itch.io */
  id: number;
  /** Canonical address of the game's page on itch.io */
  url: string;
  /** Human-friendly title (may contain any character) */
  title: string;
  /** Human-friendly short description */
  shortText: string;
  /** Downloadable game, html game, etc. */
  type: GameType;
  /** Classification: game, tool, comic, etc. */
  classification: GameClassification;
  /** Configuration for embedded (HTML5) games */
  embed?: GameEmbedInfo;
  /** Cover url (might be a GIF) */
  coverUrl: string;
  /** Non-gif cover url, only set if main cover url is a GIF */
  stillCoverUrl: string;
  /** Date the game was created */
  createdAt: string;
  /** Date the game was published, empty if not currently published */
  publishedAt: string;
  /** Price in cents of a dollar */
  minPrice: number;
  /** Can this game be bought? */
  canBeBought: boolean;
  /** Is this game downloadable by press users for free? */
  inPressSystem: boolean;
  /** Does this game have a demo that can be downloaded for free? */
  hasDemo: boolean;
  /** Does this game have an upload tagged with 'macOS compatible'? (creator-controlled) */
  pOsx: boolean;
  /** Does this game have an upload tagged with 'Linux compatible'? (creator-controlled) */
  pLinux: boolean;
  /** Does this game have an upload tagged with 'Windows compatible'? (creator-controlled) */
  pWindows: boolean;
  /** Does this game have an upload tagged with 'Android compatible'? (creator-controlled) */
  pAndroid: boolean;
  /** The user account this game is associated to */
  user?: User;
  /** ID of the user account this game is associated to */
  userId: number;
  /** The best current sale for this game */
  sale?: Sale;
}

/**
 * Type of an itch.io game page, mostly related to
 * how it should be presented on web (downloadable or embed)
 */
export enum GameType {
  // downloadable
  Default = "default",
  // .swf (legacy)
  Flash = "flash",
  // .unity3d (legacy)
  Unity = "unity",
  // .jar (legacy)
  Java = "java",
  // .html (thriving)
  HTML = "html",
}

/**
 * Creator-picked classification for a page
 */
export enum GameClassification {
  // something you can play
  Game = "game",
  // all software pretty much
  Tool = "tool",
  // assets: graphics, sounds, etc.
  Assets = "assets",
  // game mod (no link to game, purely creator tagging)
  GameMod = "game_mod",
  // printable / board / card game
  PhysicalGame = "physical_game",
  // bunch of music files
  Soundtrack = "soundtrack",
  // anything that creators think don't fit in any other category
  Other = "other",
  // comic book (pdf, jpg, specific comic formats, etc.)
  Comic = "comic",
  // book (pdf, jpg, specific e-book formats, etc.)
  Book = "book",
}

/**
 * Presentation information for embed games
 */
export interface GameEmbedInfo {
  /** width of the initial viewport, in pixels */
  width: number;
  /** height of the initial viewport, in pixels */
  height: number;
  /** for itch.io website, whether or not a fullscreen button should be shown */
  fullscreen: boolean;
}

/**
 * Describes a discount for a game.
 */
export interface Sale {
  /** Site-wide unique identifier generated by itch.io */
  id: number;
  /**
   * Discount rate in percent.
   * Can be negative, see https://itch.io/updates/introducing-reverse-sales
   */
  rate: number;
  /** Timestamp the sale started at */
  startDate: string;
  /** Timestamp the sale ends at */
  endDate: string;
}

/**
 * An Upload is a downloadable file. Some are wharf-enabled, which means
 * they're actually a "channel" that may contain multiple builds, pushed
 * with <https://github.com/itchio/butler>
 */
export interface Upload {
  /** Site-wide unique identifier generated by itch.io */
  id: number;
  /** Original file name (example: `Overland_x64.zip`) */
  filename: string;
  /** Human-friendly name set by developer (example: `Overland for Windows 64-bit`) */
  displayName: string;
  /** Size of upload in bytes. For wharf-enabled uploads, it's the archive size. */
  size: number;
  /** Name of the wharf channel for this upload, if it's a wharf-enabled upload */
  channelName: string;
  /** Latest build for this upload, if it's a wharf-enabled upload */
  build: Build;
  /** Is this upload a demo that can be downloaded for free? */
  demo: boolean;
  /** Is this upload a pre-order placeholder? */
  preorder: boolean;
  /** Upload type: default, soundtrack, etc. */
  type: string;
  /** Is this upload tagged with 'macOS compatible'? (creator-controlled) */
  pOsx: boolean;
  /** Is this upload tagged with 'Linux compatible'? (creator-controlled) */
  pLinux: boolean;
  /** Is this upload tagged with 'Windows compatible'? (creator-controlled) */
  pWindows: boolean;
  /** Is this upload tagged with 'Android compatible'? (creator-controlled) */
  pAndroid: boolean;
  /** Date this upload was created at */
  createdAt: string;
  /** Date this upload was last updated at (order changed, display name set, etc.) */
  updatedAt: string;
}

/**
 * A Collection is a set of games, curated by humans.
 */
export interface Collection {
  /** Site-wide unique identifier generated by itch.io */
  id: number;
  /** Human-friendly title for collection, for example `Couch coop games` */
  title: string;
  /** Date this collection was created at */
  createdAt: string;
  /** Date this collection was last updated at (item added, title set, etc.) */
  updatedAt: string;
  /**
   * Number of games in the collection. This might not be accurate
   * as some games might not be accessible to whoever is asking (project
   * page deleted, visibility level changed, etc.)
   */
  gamesCount: number;
}

/**
 * A download key is often generated when a purchase is made, it
 * allows downloading uploads for a game that are not available
 * for free.
 */
export interface DownloadKey {
  /** Site-wide unique identifier generated by itch.io */
  id: number;
  /** Identifier of the game to which this download key grants access */
  gameId: number;
  /** Game to which this download key grants access */
  game: Game;
  /** Date this key was created at (often coincides with purchase time) */
  createdAt: string;
  /** Date this key was last updated at */
  updatedAt: string;
  /** Identifier of the itch.io user to which this key belongs */
  ownerId: number;
}

/**
 * Build contains information about a specific build
 */
export interface Build {
  /** Site-wide unique identifier generated by itch.io */
  id: number;
  /**
   * Identifier of the build before this one on the same channel,
   * or 0 if this is the initial build.
   */
  parentBuildId: number;
  /** State of the build: started, processing, etc. */
  state: BuildState;
  /** Automatically-incremented version number, starting with 1 */
  version: number;
  /**
   * Value specified by developer with `--userversion` when pushing a build
   * Might not be unique across builds of a given channel.
   */
  userVersion: string;
  /**
   * Files associated with this build - often at least an archive,
   * a signature, and a patch. Some might be missing while the build
   * is still processing or if processing has failed.
   */
  files: BuildFile[];
  /** User who pushed the build */
  user: User;
  /** Timestamp the build was created at */
  createdAt: string;
  /** Timestamp the build was last updated at */
  updatedAt: string;
}

/**
 * BuildState describes the state of a build, relative to its initial upload, and
 * its processing.
 */
export enum BuildState {
  // BuildStateStarted is the state of a build from its creation until the initial upload is complete
  Started = "started",
  // BuildStateProcessing is the state of a build from the initial upload's completion to its fully-processed state.
  // This state does not mean the build is actually being processed right now, it's just queued for processing.
  Processing = "processing",
  // BuildStateCompleted means the build was successfully processed. Its patch hasn't necessarily been
  // rediff'd yet, but we have the holy (patch,signature,archive) trinity.
  Completed = "completed",
  // BuildStateFailed means something went wrong with the build. A failing build will not update the channel
  // head and can be requeued by the itch.io team, although if a new build is pushed before they do,
  // that new build will "win".
  Failed = "failed",
}

/**
 * BuildFile contains information about a build's "file", which could be its
 * archive, its signature, its patch, etc.
 */
export interface BuildFile {
  /** Site-wide unique identifier generated by itch.io */
  id: number;
  /** Size of this build file */
  size: number;
  /** State of this file: created, uploading, uploaded, etc. */
  state: BuildFileState;
  /** Type of this build file: archive, signature, patch, etc. */
  type: BuildFileType;
  /** Subtype of this build file, usually indicates compression */
  subType: BuildFileSubType;
  /** Date this build file was created at */
  createdAt: string;
  /** Date this build file was last updated at */
  updatedAt: string;
}

/**
 * BuildFileState describes the state of a specific file for a build
 */
export enum BuildFileState {
  // BuildFileStateCreated means the file entry exists on itch.io
  Created = "created",
  // BuildFileStateUploading means the file is currently being uploaded to storage
  Uploading = "uploading",
  // BuildFileStateUploaded means the file is ready
  Uploaded = "uploaded",
  // BuildFileStateFailed means the file failed uploading
  Failed = "failed",
}

/**
 * BuildFileType describes the type of a build file: patch, archive, signature, etc.
 */
export enum BuildFileType {
  // BuildFileTypePatch describes wharf patch files (.pwr)
  Patch = "patch",
  // BuildFileTypeArchive describes canonical archive form (.zip)
  Archive = "archive",
  // BuildFileTypeSignature describes wharf signature files (.pws)
  Signature = "signature",
  // BuildFileTypeManifest is reserved
  Manifest = "manifest",
  // BuildFileTypeUnpacked describes the single file that is in the build (if it was just a single file)
  Unpacked = "unpacked",
}

/**
 * BuildFileSubType describes the subtype of a build file: mostly its compression
 * level. For example, rediff'd patches are "optimized", whereas initial patches are "default"
 */
export enum BuildFileSubType {
  // BuildFileSubTypeDefault describes default compression (rsync patches)
  Default = "default",
  // BuildFileSubTypeGzip is reserved
  Gzip = "gzip",
  // BuildFileSubTypeOptimized describes optimized compression (rediff'd / bsdiff patches)
  Optimized = "optimized",
}

/**
 * A Verdict contains a wealth of information on how to "launch" or "open" a specific
 * folder.
 */
export interface Verdict {
  /** BasePath is the absolute path of the folder that was configured */
  basePath: string;
  /** TotalSize is the size in bytes of the folder and all its children, recursively */
  totalSize: number;
  /** Candidates is a list of potentially interesting files, with a lot of additional info */
  candidates: Candidate[];
}

/**
 * A Candidate is a potentially interesting launch target, be it
 * a native executable, a Java or Love2D bundle, an HTML index, etc.
 */
export interface Candidate {
  /** Path is relative to the configured folder */
  path: string;
  /** Mode describes file permissions */
  mode: number;
  /** Depth is the number of path elements leading up to this candidate */
  depth: number;
  /** Flavor is the type of a candidate - native, html, jar etc. */
  flavor: Flavor;
  /** Arch describes the architecture of a candidate (where relevant) */
  arch: Arch;
  /** Size is the size of the candidate's file, in bytes */
  size: number;
  /** Spell contains raw output from <https://github.com/fasterthanlime/wizardry> */
  spell?: string[];
  /** WindowsInfo contains information specific to native Windows candidates */
  windowsInfo?: WindowsInfo;
  /** LinuxInfo contains information specific to native Linux candidates */
  linuxInfo?: LinuxInfo;
  /** MacosInfo contains information specific to native macOS candidates */
  macosInfo?: MacosInfo;
  /** LoveInfo contains information specific to Love2D bundles (`.love` files) */
  loveInfo?: LoveInfo;
  /** ScriptInfo contains information specific to shell scripts (`.sh`, `.bat` etc.) */
  scriptInfo?: ScriptInfo;
  /** JarInfo contains information specific to Java archives (`.jar` files) */
  jarInfo?: JarInfo;
}

/**
 * Flavor describes whether we're dealing with a native executables, a Java archive, a love2d bundle, etc.
 */
export enum Flavor {
  // FlavorNativeLinux denotes native linux executables
  NativeLinux = "linux",
  // ExecNativeMacos denotes native macOS executables
  NativeMacos = "macos",
  // FlavorPe denotes native windows executables
  NativeWindows = "windows",
  // FlavorAppMacos denotes a macOS app bundle
  AppMacos = "app-macos",
  // FlavorScript denotes scripts starting with a shebang (#!)
  Script = "script",
  // FlavorScriptWindows denotes windows scripts (.bat or .cmd)
  ScriptWindows = "windows-script",
  // FlavorJar denotes a .jar archive with a Main-Class
  Jar = "jar",
  // FlavorHTML denotes an index html file
  HTML = "html",
  // FlavorLove denotes a love package
  Love = "love",
}

/**
 * The architecture of an executable
 */
export enum Arch {
  // 32-bit
  _386 = "386",
  // 64-bit
  Amd64 = "amd64",
}

/**
 * Contains information specific to native windows executables
 * or installer packages.
 */
export interface WindowsInfo {
  /** Particular type of installer (msi, inno, etc.) */
  installerType?: WindowsInstallerType;
  /** True if we suspect this might be an uninstaller rather than an installer */
  uninstaller?: boolean;
  /** Is this executable marked as GUI? This can be false and still pop a GUI, it's just a hint. */
  gui?: boolean;
  /** Is this a .NET assembly? */
  dotNet?: boolean;
}

/**
 * Which particular type of windows-specific installer
 */
export enum WindowsInstallerType {
  // Microsoft install packages (`.msi` files)
  Msi = "msi",
  // InnoSetup installers
  Inno = "inno",
  // NSIS installers
  Nullsoft = "nsis",
  // Self-extracting installers that 7-zip knows how to extract
  Archive = "archive",
}

/**
 * Contains information specific to native macOS executables
 * or app bundles.
 */
export interface MacosInfo {
  // no fields
}

/**
 * Contains information specific to native Linux executables
 */
export interface LinuxInfo {
  // no fields
}

/**
 * Contains information specific to Love2D bundles
 */
export interface LoveInfo {
  /** The version of love2D required to open this bundle. May be empty */
  version?: string;
}

/**
 * Contains information specific to shell scripts
 */
export interface ScriptInfo {
  /** Something like `/bin/bash` */
  interpreter?: string;
}

/**
 * Contains information specific to Java archives
 */
export interface JarInfo {
  /** The main Java class as specified by the manifest included in the .jar (if any) */
  mainClass?: string;
}

/**
 * A Receipt describes what was installed to a specific folder.
 * 
 * It's compressed and written to `./.itch/receipt.json.gz` every
 * time an install operation completes successfully, and is used
 * in further install operations to make sure ghosts are busted and/or
 * angels are saved.
 */
export interface Receipt {
  /** The itch.io game installed at this location */
  game: Game;
  /** The itch.io upload installed at this location */
  upload: Upload;
  /** The itch.io build installed at this location. Null for non-wharf upload. */
  build: Build;
  /** A list of installed files (slash-separated paths, relative to install folder) */
  files: string[];
  /** The installer used to install at this location */
  installerName?: string;
  /**
   * If this was installed from an MSI package, the product code,
   * used for a clean uninstall.
   */
  msiProductCode?: string;
}

/**
 * Finds uploads compatible with the current runtime, for a given game.
 */
export interface GameFindUploadsParams {
  /** Which game to find uploads for */
  game: Game;
  /** The credentials to use to list uploads */
  credentials: GameCredentials;
}

/**
 * Start a new operation (installing or uninstalling).
 * 
 * Can be cancelled by passing the same `ID` to @@OperationCancelParams.
 */
export interface OperationStartParams {
  /**
   * A UUID, generated by the client, used for referring to the
   * task when cancelling it, for instance.
   */
  id: string;
  /**
   * A folder that butler can use to store temporary files, like
   * partial downloads, checkpoint files, etc.
   */
  stagingFolder: string;
  /** Which operation to perform */
  operation: Operation;
  /** Must be set if Operation is `install` */
  installParams?: InstallParams;
  /** Must be set if Operation is `uninstall` */
  uninstallParams?: UninstallParams;
}

/**
 * undocumented
 */
export enum Operation {
  // Install a game (includes upgrades, heals, etc.)
  Install = "install",
  // Uninstall a game
  Uninstall = "uninstall",
}

/**
 * Attempt to gracefully cancel an ongoing operation.
 */
export interface OperationCancelParams {
  /** The UUID of the task to cancel, as passed to @@OperationStartParams */
  id: string;
}

/**
 * InstallParams contains all the parameters needed to perform
 * an installation for a game via @@OperationStartParams.
 */
export interface InstallParams {
  /** Which game to install */
  game: Game;
  /** An absolute path where to install the game */
  installFolder: string;
  /** Which upload to install */
  upload?: Upload;
  /** Which build to install */
  build?: Build;
  /** Which credentials to use to install the game */
  credentials: GameCredentials;
  /**
   * If true, do not run windows installers, just extract
   * whatever to the install folder.
   */
  ignoreInstallers?: boolean;
}

/**
 * UninstallParams contains all the parameters needed to perform
 * an uninstallation for a game via @@OperationStartParams.
 */
export interface UninstallParams {
  /** Absolute path of the folder butler should uninstall */
  installFolder: string;
}

/**
 * Asks the user to pick between multiple available uploads
 */
export interface PickUploadParams {
  /** An array of upload objects to choose from */
  uploads: Upload[];
}

/**
 * Retrieves existing receipt information for an install
 */
export interface GetReceiptParams {
  // no fields
}

/**
 * Sent periodically during @@OperationStartParams to inform on the current state an operation.
 */
export interface OperationProgressNotification {
  /** An overall progress value between 0 and 1 */
  progress: number;
  /** Estimated completion time for the operation, in seconds (floating) */
  eta: number;
  /** Network bandwidth used, in bytes per second (floating) */
  bps: number;
}

export const OperationProgress = 
	createNotification<OperationProgressNotification>("Operation.Progress");

/**
 * undocumented
 */
export enum TaskReason {
  // Task was started for an install operation
  Install = "install",
  // Task was started for an uninstall operation
  Uninstall = "uninstall",
}

/**
 * undocumented
 */
export enum TaskType {
  // We're fetching files from a remote server
  Download = "download",
  // We're running an installer
  Install = "install",
  // We're running an uninstaller
  Uninstall = "uninstall",
  // We're applying some patches
  Update = "update",
  // We're healing from a signature and heal source
  Heal = "heal",
}

/**
 * Each operation is made up of one or more tasks. This notification
 * is sent during @@OperationStartParams whenever a specific task starts.
 */
export interface TaskStartedNotification {
  /** Why this task was started */
  reason: TaskReason;
  /** Is this task a download? An install? */
  type: TaskType;
  /** The game this task is dealing with */
  game: Game;
  /** The upload this task is dealing with */
  upload: Upload;
  /** The build this task is dealing with (if any) */
  build: Build;
  /** Total size in bytes */
  totalSize: number;
}

export const TaskStarted = 
	createNotification<TaskStartedNotification>("TaskStarted");

/**
 * Sent during @@OperationStartParams whenever a task succeeds for an operation.
 */
export interface TaskSucceededNotification {
  /** undocumented */
  type: TaskType;
  /**
   * If the task installed something, then this contains
   * info about the game, upload, build that were installed
   */
  installResult: InstallResult;
}

export const TaskSucceeded = 
	createNotification<TaskSucceededNotification>("TaskSucceeded");

/**
 * What was installed by a subtask of @@OperationStartParams.
 * 
 * See @@TaskSucceededNotification.
 */
export interface InstallResult {
  /** The game we installed */
  game: Game;
  /** The upload we installed */
  upload: Upload;
  /** The build we installed */
  build?: Build;
}

/**
 * Looks for one or more game updates.
 * 
 * Updates found are regularly sent via @@GameUpdateAvailableNotification, and
 * then all at once in the result.
 */
export interface CheckUpdateParams {
  /** A list of items, each of it will be checked for updates */
  items: CheckUpdateItem[];
}

/**
 * undocumented
 */
export interface CheckUpdateItem {
  /**
   * An UUID generated by the client, which allows it to map back the
   * results to its own items.
   */
  itemId: string;
  /** Timestamp of the last successful install operation */
  installedAt: string;
  /** Game for which to look for an update */
  game: Game;
  /** Currently installed upload */
  upload: Upload;
  /** Currently installed build */
  build: Build;
  /** Credentials to use to list uploads */
  credentials: GameCredentials;
}

/**
 * Sent during @@CheckUpdateParams, every time butler
 * finds an update for a game. Can be safely ignored if displaying
 * updates as they are found is not a requirement for the client.
 */
export interface GameUpdateAvailableNotification {
  /** undocumented */
  update: GameUpdate;
}

export const GameUpdateAvailable = 
	createNotification<GameUpdateAvailableNotification>("GameUpdateAvailable");

/**
 * Describes an available update for a particular game install.
 */
export interface GameUpdate {
  /** Identifier originally passed in CheckUpdateItem */
  itemId: string;
  /** Game we found an update for */
  game: Game;
  /** Upload to be installed */
  upload: Upload;
  /** Build to be installed (may be nil) */
  build: Build;
}

/**
 * Attempt to launch an installed game.
 */
export interface LaunchParams {
  /** The folder the game was installed to */
  installFolder: string;
  /** The itch.io game that was installed */
  game: Game;
  /** The itch.io upload that was installed */
  upload: Upload;
  /** The itch.io build that was installed */
  build: Build;
  /** The stored verdict from when the folder was last configured (can be null) */
  verdict: Verdict;
  /** The directory to use to store installer files for prerequisites */
  prereqsDir: string;
  /** Force installing all prerequisites, even if they're already marked as installed */
  forcePrereqs?: boolean;
  /** Enable sandbox (regardless of manifest opt-in) */
  sandbox: boolean;
  /**
   * itch.io credentials to use for any necessary API
   * requests (prereqs downloads, subkeying, etc.)
   */
  credentials: GameCredentials;
}

/**
 * Sent during @@LaunchParams, when the game is configured, prerequisites are installed
 * sandbox is set up (if enabled), and the game is actually running.
 */
export interface LaunchRunningNotification {
  // no fields
}

export const LaunchRunning = 
	createNotification<LaunchRunningNotification>("LaunchRunning");

/**
 * Sent during @@LaunchParams, when the game has actually exited.
 */
export interface LaunchExitedNotification {
  // no fields
}

export const LaunchExited = 
	createNotification<LaunchExitedNotification>("LaunchExited");

/**
 * Sent during @@LaunchParams, ask the user to pick a manifest action to launch.
 * 
 * See [itch app manifests](https://itch.io/docs/itch/integrating/manifest.html).
 */
export interface PickManifestActionParams {
  /** A list of actions to pick from. Must be shown to the user in the order they're passed. */
  actions: Action[];
}

/**
 * Ask the client to perform a shell launch, ie. open an item
 * with the operating system's default handler (File explorer).
 * 
 * Sent during @@LaunchParams.
 */
export interface ShellLaunchParams {
  /** Absolute path of item to open, e.g. `D:\\Games\\Itch\\garden\\README.txt` */
  itemPath: string;
}

/**
 * Ask the client to perform an HTML launch, ie. open an HTML5
 * game, ideally in an embedded browser.
 * 
 * Sent during @@LaunchParams.
 */
export interface HTMLLaunchParams {
  /** Absolute path on disk to serve */
  rootFolder: string;
  /** Path of index file, relative to root folder */
  indexPath: string;
  /** Command-line arguments, to pass as `global.Itch.args` */
  args: string[];
  /** Environment variables, to pass as `global.Itch.env` */
  env: Map<string, string>;
}

/**
 * Ask the client to perform an URL launch, ie. open an address
 * with the system browser or appropriate.
 * 
 * Sent during @@LaunchParams.
 */
export interface URLLaunchParams {
  /** URL to open, e.g. `https://itch.io/community` */
  url: string;
}

/**
 * Ask the client to save verdict information after a reconfiguration.
 * 
 * Sent during @@LaunchParams.
 */
export interface SaveVerdictParams {
  /** undocumented */
  verdict: Verdict;
}

/**
 * Ask the user to allow sandbox setup. Will be followed by
 * a UAC prompt (on Windows) or a pkexec dialog (on Linux) if
 * the user allows.
 * 
 * Sent during @@LaunchParams.
 */
export interface AllowSandboxSetupParams {
  // no fields
}

/**
 * Sent during @@LaunchParams, when some prerequisites are about to be installed.
 * 
 * This is a good time to start showing a UI element with the state of prereq
 * tasks.
 * 
 * Updates are regularly provided via @@PrereqsTaskStateNotification.
 */
export interface PrereqsStartedNotification {
  /** A list of prereqs that need to be tended to */
  tasks: Map<string, PrereqTask>;
}

export const PrereqsStarted = 
	createNotification<PrereqsStartedNotification>("PrereqsStarted");

/**
 * Information about a prerequisite task.
 */
export interface PrereqTask {
  /** Full name of the prerequisite, for example: `Microsoft .NET Framework 4.6.2` */
  fullName: string;
  /** Order of task in the list. Respect this order in the UI if you want consistent progress indicators. */
  order: number;
}

/**
 * Current status of a prerequisite task
 * 
 * Sent during @@LaunchParams, after @@PrereqsStartedNotification, repeatedly
 * until all prereq tasks are done.
 */
export interface PrereqsTaskStateNotification {
  /** Short name of the prerequisite task (e.g. `xna-4.0`) */
  name: string;
  /** Current status of the prereq */
  status: PrereqStatus;
  /** Value between 0 and 1 (floating) */
  progress: number;
  /** ETA in seconds (floating) */
  eta: number;
  /** Network bandwidth used in bytes per second (floating) */
  bps: number;
}

export const PrereqsTaskState = 
	createNotification<PrereqsTaskStateNotification>("PrereqsTaskState");

/**
 * undocumented
 */
export enum PrereqStatus {
  // Prerequisite has not started downloading yet
  Pending = "pending",
  // Prerequisite is currently being downloaded
  Downloading = "downloading",
  // Prerequisite has been downloaded and is pending installation
  Ready = "ready",
  // Prerequisite is currently installing
  Installing = "installing",
  // Prerequisite was installed (successfully or not)
  Done = "done",
}

/**
 * Sent during @@LaunchParams, when all prereqs have finished installing (successfully or not)
 * 
 * After this is received, it's safe to close any UI element showing prereq task state.
 */
export interface PrereqsEndedNotification {
  // no fields
}

export const PrereqsEnded = 
	createNotification<PrereqsEndedNotification>("PrereqsEnded");

/**
 * Sent during @@LaunchParams, when one or more prerequisites have failed to install.
 * The user may choose to proceed with the launch anyway.
 */
export interface PrereqsFailedParams {
  /** Short error */
  error: string;
  /** Longer error (to include in logs) */
  errorStack: string;
}

/**
 * Look for folders we can clean up in various download folders.
 * This finds anything that doesn't correspond to any current downloads
 * we know about.
 */
export interface CleanDownloadsSearchParams {
  /** A list of folders to scan for potential subfolders to clean up */
  roots: string[];
  /**
   * A list of subfolders to not consider when cleaning
   * (staging folders for in-progress downloads)
   */
  whitelist: string[];
}

/**
 * Result for CleanDownloads.Search
 */
export interface CleanDownloadsSearchResult {
  /** Entries we found that could use some cleaning (with path and size information) */
  entries: CleanDownloadsEntry[];
}

export const CleanDownloadsSearch = 
	createRequest<CleanDownloadsSearchParams, CleanDownloadsSearchResult>("CleanDownloads.Search");

/**
 * undocumented
 */
export interface CleanDownloadsEntry {
  /** The complete path of the file or folder we intend to remove */
  path: string;
  /** The size of the folder or file, in bytes */
  size: number;
}

/**
 * Remove the specified entries from disk, freeing up disk space.
 */
export interface CleanDownloadsApplyParams {
  /** undocumented */
  entries: CleanDownloadsEntry[];
}

/**
 * Result for CleanDownloads.Apply
 */
export interface CleanDownloadsApplyResult {
  // no fields
}

export const CleanDownloadsApply = 
	createRequest<CleanDownloadsApplyParams, CleanDownloadsApplyResult>("CleanDownloads.Apply");

/**
 * Test request: asks butler to double a number twice.
 * First by calling @@TestDoubleParams, then by
 * returning the result of that call doubled.
 * 
 * Use that to try out your JSON-RPC 2.0 over TCP implementation.
 */
export interface TestDoubleTwiceParams {
  /** The number to quadruple */
  number: number;
}

/**
 * Result for Test.DoubleTwice
 */
export interface TestDoubleTwiceResult {
  /** The input, quadrupled */
  number: number;
}

export const TestDoubleTwice = 
	createRequest<TestDoubleTwiceParams, TestDoubleTwiceResult>("Test.DoubleTwice");

/**
 * Test request: return a number, doubled. Implement that to
 * use @@TestDoubleTwiceParams in your testing.
 */
export interface TestDoubleParams {
  /** The number to double */
  number: number;
}
